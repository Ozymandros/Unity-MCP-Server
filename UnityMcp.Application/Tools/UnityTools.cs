using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using UnityMcp.Core.Interfaces;

namespace UnityMcp.Application.Tools;

/// <summary>
/// Unity MCP tool definitions using the official ModelContextProtocol SDK attributes.
/// Each method is automatically discovered and registered by the SDK.
/// AI agents call these tools through the MCP protocol to create Unity content.
/// </summary>
[McpServerToolType]
public static class UnityTools
{
    // -----------------------------------------------------------------------
    // Connectivity
    // -----------------------------------------------------------------------

    [McpServerTool(Name = "ping"), Description("Check server connectivity")]
    public static string Ping() => "pong";

    // -----------------------------------------------------------------------
    // Basic file tools (existing)
    // -----------------------------------------------------------------------

    [McpServerTool(Name = "unity_create_scene"), Description("Creates a new Unity scene file with default camera and light")]
    public static async Task<string> CreateScene(
        IUnityService unityService,
        [Description("Relative path to the new scene (e.g. Assets/Scenes/NewScene.unity)")]
        string path,
        CancellationToken cancellationToken = default)
    {
        await unityService.CreateSceneAsync(path, cancellationToken);
        return $"Scene created at {path}";
    }

    [McpServerTool(Name = "unity_create_script"), Description(
        "Creates a C# script file. If content is provided, writes the full AI-generated code. " +
        "Otherwise creates a default MonoBehaviour template. " +
        "Example content: 'using UnityEngine;\\npublic class Player : MonoBehaviour { void Update() { transform.Translate(Vector3.forward * Time.deltaTime); } }'")]
    public static async Task<string> CreateScript(
        IUnityService unityService,
        [Description("Relative path to the script file (e.g. Assets/Scripts/Player.cs)")]
        string path,
        [Description("Name of the class (e.g. Player)")]
        string scriptName,
        [Description("Full C# script content generated by the AI. If omitted, a default MonoBehaviour template is used.")]
        string? content = null,
        CancellationToken cancellationToken = default)
    {
        await unityService.CreateScriptAsync(path, scriptName, content, cancellationToken);
        return $"Script {scriptName} created at {path}";
    }

    [McpServerTool(Name = "unity_list_assets"), Description("Lists files in the Unity project directory")]
    public static async Task<IEnumerable<string>> ListAssets(
        IUnityService unityService,
        [Description("Path to start listing from (default: Assets)")]
        string path = "Assets",
        [Description("Search pattern, e.g. *.cs, *.unity (default: *)")]
        string pattern = "*",
        CancellationToken cancellationToken = default)
    {
        return await unityService.ListAssetsAsync(path, pattern, cancellationToken);
    }

    [McpServerTool(Name = "unity_create_asset"), Description("Creates a generic text asset file")]
    public static async Task<string> CreateAsset(
        IUnityService unityService,
        [Description("Relative path to the new asset")]
        string path,
        [Description("Text content of the asset")]
        string content = "",
        CancellationToken cancellationToken = default)
    {
        await unityService.CreateAssetAsync(path, content, cancellationToken);
        return $"Asset created at {path}";
    }

    [McpServerTool(Name = "unity_build_project"), Description("Builds the Unity project for a specific target (requires Unity installed)")]
    public static async Task<string> BuildProject(
        IUnityService unityService,
        [Description("Build target (Win64, OSX, Linux64)")]
        string target,
        [Description("Absolute path for the build output")]
        string outputPath,
        CancellationToken cancellationToken = default)
    {
        await unityService.BuildProjectAsync(target, outputPath, cancellationToken);
        return $"Build completed for target {target} at {outputPath}";
    }

    // -----------------------------------------------------------------------
    // Enhanced AI-driven scene authoring tools (NEW)
    // -----------------------------------------------------------------------

    [McpServerTool(Name = "unity_create_detailed_scene"), Description(
        "Creates a Unity scene with detailed GameObjects. " +
        "Pass a JSON array of GameObjects, each with name, position, scale, eulerAngles, " +
        "and components (Camera, Light, MeshFilter, MeshRenderer, BoxCollider, SphereCollider, Rigidbody, AudioSource). " +
        "Example: [{\"name\":\"Main Camera\",\"tag\":\"MainCamera\",\"position\":{\"x\":0,\"y\":1,\"z\":-10}," +
        "\"components\":[{\"type\":\"Camera\",\"fov\":60}]}]")]
    public static async Task<string> CreateDetailedScene(
        IUnityService unityService,
        [Description("Relative path for the scene file (e.g. Assets/Scenes/Level1.unity)")]
        string path,
        [Description("JSON array of GameObjects with name, position, scale, eulerAngles, and components")]
        string sceneJson,
        CancellationToken cancellationToken = default)
    {
        await unityService.CreateDetailedSceneAsync(path, sceneJson, cancellationToken);
        return $"Detailed scene created at {path}";
    }

    [McpServerTool(Name = "unity_add_gameobject"), Description(
        "Appends a GameObject to an existing scene file. " +
        "Pass a JSON object with name, position, scale, eulerAngles, and an array of components. " +
        "Component types: Camera, Light, MeshFilter, MeshRenderer, BoxCollider, SphereCollider, " +
        "CapsuleCollider, Rigidbody, AudioSource. " +
        "Example: {\"name\":\"Cube\",\"position\":{\"x\":0,\"y\":0.5,\"z\":0}," +
        "\"components\":[{\"type\":\"MeshFilter\",\"mesh\":\"Cube\"},{\"type\":\"MeshRenderer\"},{\"type\":\"BoxCollider\"}]}")]
    public static async Task<string> AddGameObject(
        IUnityService unityService,
        [Description("Path to the existing scene file")]
        string scenePath,
        [Description("JSON object defining the GameObject (name, position, scale, eulerAngles, components)")]
        string gameObjectJson,
        CancellationToken cancellationToken = default)
    {
        await unityService.AddGameObjectToSceneAsync(scenePath, gameObjectJson, cancellationToken);
        return $"GameObject added to {scenePath}";
    }

    [McpServerTool(Name = "unity_create_material"), Description(
        "Creates a Unity material file (.mat). " +
        "Pass a JSON object with name, color {r,g,b,a}, metallic (0-1), smoothness (0-1), " +
        "emissionColor {r,g,b,a}, renderMode (0=Opaque,1=Cutout,2=Fade,3=Transparent). " +
        "Example: {\"name\":\"RedMetal\",\"color\":{\"r\":1,\"g\":0,\"b\":0,\"a\":1},\"metallic\":0.8,\"smoothness\":0.6}")]
    public static async Task<string> CreateMaterial(
        IUnityService unityService,
        [Description("Relative path for the material file (e.g. Assets/Materials/RedMetal.mat)")]
        string path,
        [Description("JSON object with material properties (name, color, metallic, smoothness, emissionColor, renderMode)")]
        string materialJson,
        CancellationToken cancellationToken = default)
    {
        await unityService.CreateMaterialAsync(path, materialJson, cancellationToken);
        return $"Material created at {path}";
    }

    [McpServerTool(Name = "unity_create_prefab"), Description(
        "Creates a Unity prefab file (.prefab). " +
        "Pass a JSON object with name, position, scale, eulerAngles, and components — same format as unity_add_gameobject. " +
        "Example: {\"name\":\"Enemy\",\"components\":[{\"type\":\"MeshFilter\",\"mesh\":\"Capsule\"},{\"type\":\"MeshRenderer\"},{\"type\":\"CapsuleCollider\"},{\"type\":\"Rigidbody\",\"mass\":2}]}")]
    public static async Task<string> CreatePrefab(
        IUnityService unityService,
        [Description("Relative path for the prefab file (e.g. Assets/Prefabs/Enemy.prefab)")]
        string path,
        [Description("JSON object defining the root GameObject (name, position, scale, components)")]
        string prefabJson,
        CancellationToken cancellationToken = default)
    {
        await unityService.CreatePrefabAsync(path, prefabJson, cancellationToken);
        return $"Prefab created at {path}";
    }

    [McpServerTool(Name = "unity_read_asset"), Description("Reads the text content of a file in the Unity project")]
    public static async Task<string> ReadAsset(
        IUnityService unityService,
        [Description("Path to the file to read")]
        string path,
        CancellationToken cancellationToken = default)
    {
        return await unityService.ReadAssetAsync(path, cancellationToken);
    }

    [McpServerTool(Name = "unity_delete_asset"), Description("Deletes a file from the Unity project (also removes .meta sidecar)")]
    public static async Task<string> DeleteAsset(
        IUnityService unityService,
        [Description("Path to the file to delete")]
        string path,
        CancellationToken cancellationToken = default)
    {
        await unityService.DeleteAssetAsync(path, cancellationToken);
        return $"Deleted {path}";
    }

    [McpServerTool(Name = "unity_create_gameobject"), Description("Creates a simple named GameObject in an existing scene (legacy — prefer unity_add_gameobject for full control)")]
    public static async Task<string> CreateGameObject(
        IUnityService unityService,
        [Description("Path to the scene file")]
        string scenePath,
        [Description("Name of the new GameObject")]
        string gameObjectName,
        CancellationToken cancellationToken = default)
    {
        await unityService.CreateGameObjectAsync(scenePath, gameObjectName, cancellationToken);
        return $"GameObject {gameObjectName} created in {scenePath}";
    }

    // -----------------------------------------------------------------------
    // Project scaffolding & management
    // -----------------------------------------------------------------------

    [McpServerTool(Name = "unity_scaffold_project"), Description(
        "Scaffolds a complete Unity project skeleton with Assets/, Scripts/, Textures/, Audio/, " +
        "Scenes/, Prefabs/, Materials/, Text/, ProjectSettings/, and Packages/ — all with .meta sidecars. " +
        "Idempotent: reuses the project folder if it already exists. Returns the absolute path.")]
    public static async Task<string> ScaffoldProject(
        IUnityService unityService,
        [Description("Project folder name (e.g. MyGame). Used as-is — no timestamps added.")]
        string projectName,
        [Description("Parent directory for the project (default: ./output)")]
        string? outputRoot = null,
        [Description("Unity version for ProjectVersion.txt (default: 2022.3.0f1)")]
        string? unityVersion = null,
        CancellationToken cancellationToken = default)
    {
        string path = await unityService.ScaffoldProjectAsync(projectName, outputRoot, unityVersion, cancellationToken);
        return $"Project scaffolded at {path}";
    }

    [McpServerTool(Name = "unity_get_project_info"), Description(
        "Returns project metadata (name, absolute path, Unity version, whether Assets/ exists) as JSON.")]
    public static async Task<string> GetProjectInfo(
        IUnityService unityService,
        [Description("Absolute path to the Unity project root")]
        string projectPath,
        CancellationToken cancellationToken = default)
    {
        return await unityService.GetProjectInfoAsync(projectPath, cancellationToken);
    }

    [McpServerTool(Name = "unity_create_folder"), Description(
        "Creates a folder inside the Unity project with a .meta sidecar (Unity requires .meta to track folders).")]
    public static async Task<string> CreateFolder(
        IUnityService unityService,
        [Description("Absolute or relative path of the folder to create")]
        string folderPath,
        CancellationToken cancellationToken = default)
    {
        await unityService.CreateFolderAsync(folderPath, cancellationToken);
        return $"Folder created at {folderPath} (with .meta)";
    }

    // -----------------------------------------------------------------------
    // Typed asset saving tools
    // -----------------------------------------------------------------------

    [McpServerTool(Name = "unity_save_script"), Description(
        "Saves AI-generated C# code into Assets/Scripts/ with a MonoImporter .meta sidecar. " +
        "This is the preferred way to write scripts — ensures Unity recognises the file on import.")]
    public static async Task<string> SaveScript(
        IUnityService unityService,
        [Description("Absolute path to the project root")]
        string projectPath,
        [Description("Script filename with extension (e.g. PlayerController.cs)")]
        string fileName,
        [Description("Full C# source code")]
        string content,
        CancellationToken cancellationToken = default)
    {
        await unityService.SaveScriptAsync(projectPath, fileName, content, cancellationToken);
        return $"Script {fileName} saved to {projectPath}/Assets/Scripts/ (with .meta)";
    }

    [McpServerTool(Name = "unity_save_text"), Description(
        "Saves a text asset (dialogue, narrative, JSON data) into Assets/Text/ with a .meta sidecar.")]
    public static async Task<string> SaveText(
        IUnityService unityService,
        [Description("Absolute path to the project root")]
        string projectPath,
        [Description("Text filename with extension (e.g. dialogue.txt, config.json)")]
        string fileName,
        [Description("Text content to save")]
        string content,
        CancellationToken cancellationToken = default)
    {
        await unityService.SaveTextAssetAsync(projectPath, fileName, content, cancellationToken);
        return $"Text asset {fileName} saved to {projectPath}/Assets/Text/ (with .meta)";
    }

    [McpServerTool(Name = "unity_save_texture"), Description(
        "Saves a base64-encoded PNG/JPG image into Assets/Textures/ with a TextureImporter .meta sidecar.")]
    public static async Task<string> SaveTexture(
        IUnityService unityService,
        [Description("Absolute path to the project root")]
        string projectPath,
        [Description("Image filename with extension (e.g. player_sprite.png)")]
        string fileName,
        [Description("Base64-encoded image data (PNG or JPG)")]
        string base64Data,
        CancellationToken cancellationToken = default)
    {
        await unityService.SaveTextureAsync(projectPath, fileName, base64Data, cancellationToken);
        return $"Texture {fileName} saved to {projectPath}/Assets/Textures/ (with .meta)";
    }

    [McpServerTool(Name = "unity_save_audio"), Description(
        "Saves a base64-encoded audio file into Assets/Audio/ with an AudioImporter .meta sidecar.")]
    public static async Task<string> SaveAudio(
        IUnityService unityService,
        [Description("Absolute path to the project root")]
        string projectPath,
        [Description("Audio filename with extension (e.g. explosion.mp3, ambient.wav)")]
        string fileName,
        [Description("Base64-encoded audio data (MP3 or WAV)")]
        string base64Data,
        CancellationToken cancellationToken = default)
    {
        await unityService.SaveAudioAsync(projectPath, fileName, base64Data, cancellationToken);
        return $"Audio {fileName} saved to {projectPath}/Assets/Audio/ (with .meta)";
    }

    // -----------------------------------------------------------------------
    // Validation & package management
    // -----------------------------------------------------------------------

    [McpServerTool(Name = "unity_validate_csharp"), Description(
        "Validates C# syntax without compiling — checks balanced braces/parens, class keyword, using directives. " +
        "Returns JSON with isValid (bool) and errors (string[]). Use before saving scripts to catch issues early.")]
    public static async Task<string> ValidateCSharp(
        IUnityService unityService,
        [Description("Full C# source code to validate")]
        string code,
        CancellationToken cancellationToken = default)
    {
        return await unityService.ValidateCSharpAsync(code, cancellationToken);
    }

    [McpServerTool(Name = "unity_add_packages"), Description(
        "Adds UPM packages to Packages/manifest.json (merges with existing). " +
        "Pass a JSON object of package IDs to versions. " +
        "Example: {\"com.unity.render-pipelines.universal\":\"14.0.11\",\"com.unity.textmeshpro\":\"3.0.6\"}")]
    public static async Task<string> AddPackages(
        IUnityService unityService,
        [Description("Absolute path to the project root")]
        string projectPath,
        [Description("JSON object with package IDs and versions, e.g. {\"com.unity.render-pipelines.universal\":\"14.0.11\"}")]
        string packagesJson,
        CancellationToken cancellationToken = default)
    {
        await unityService.AddPackagesAsync(projectPath, packagesJson, cancellationToken);
        return $"Packages added to {projectPath}/Packages/manifest.json";
    }
}

